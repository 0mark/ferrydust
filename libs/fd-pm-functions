#!/bin/sh

PATH="$PATH:/sbin:/usr/sbin:/usr/local/sbin"

me="$(basename $0)"

shopt -s nullglob extglob

# turn on kernel options
#opt() {
#    [[ -f "$1" ]] || return
#    tee "$1" <<<"$2" &>/dev/null || echo "[$me] cannot write $2 to $1"
#}

opt() {
    if [ ! -f "$1" ]; then
        echo -e -n "${COL_YEL}.${COL_DEF}"
        return 2
    fi

    if tee "$1" <<< "$2" &> /dev/null; then
        echo -e -n "${COL_GRN}.${COL_DEF}"
        return 0
    else
        echo -e -n "${COL_RED}.${COL_DEF}"
        return 1
    fi
}

# unload kernel module
unload_mod() {
    has_mod "$1" || return
    mod_loaded "$1" || return
    modprobe -r "$1" &>/dev/null || echo "[$me] cannot unload module $1"
}

# load kernel module
load_mod() {
    has_mod "$1" || return
    mod_loaded "$1" && return
    modprobe "$1" &>/dev/null || echo "[$me] cannot load module $1"
}

# module exists
has_mod() {
    modprobe -nq "$1"
}

# module loaded
mod_loaded() {
    grep -qs "^$1 " /proc/modules
}

# brightness scale 0 to 5
# $1 = max file
# $2 = value
num_scale() {
    #local scale="$(bc <<< "($(< "$1") * 10) / 5")"
    local scale="$(bc <<< "("$1" * 10) / 5")"
    echo "$(( ( $scale * $2 ) / 10 ))"
}
# max / 5 * val
# 5 / max * val

elacs_mun() {
    #local scale="$(bc <<< "($(< "$1") * 10) / 5")"
    if [ $1 -eq 0 ]; then
        echo $2
        exit
    fi
    local scale="$(bc <<< "(5 * 1000 + 500) / "$1"")"
    echo "$(( ( $scale * $2 ) / 1000 ))"
}

# command
run() {
    if "$@" &> /dev/null; then
        echo -e -n "${COL_GRN}.${COL_DEF}"
    else
        echo -e -n "${COL_RED}.${COL_DEF}"
    fi
}

has_bat() {
	local bat
	for bat in /sys/class/power_supply/BAT*; do
		return 0
	done
	return 1
}

# get current power usage
display_power() {
    if ! has_bat; then
        echo "[$me] no battery"
        return
    fi
    local bat
    for bat in /sys/class/power_supply/BAT*; do
        local watt
        if [[ -f "$bat/power_now" ]]; then
            watt="$(bc <<< "scale=3; $(< "$bat/power_now") / 1000000")"
        else
            watt="$(bc <<< "scale=3; $(< "$bat/current_now") * $(< "$bat/voltage_now") / 1000000000000")"
        fi
        echo "[$me] $(basename "$bat") using $watt watts"
    done
}

# get readahead
display_readahead() {
    echo " -> $1 readahead: $(blockdev --getra "$1")"
}

# dump kernel option content
dump () {
    [[ -w "$1" && -r "$1" ]] || return
    echo " -> $1: $(< "$1")"
}

acdc () {
    [[ -w "$1" && -r "$1" ]] || return
    val=$(< "$1")

    if [ "$cur_state" == "1" -a "$val" == "$2" ]; then
        col=$COL_GRN
    elif [ "$cur_state" == "0" -a "$val" == "$3" ]; then
        col=$COL_GRN
    else
        col=$COL_RED
    fi
    if [ "$val" == "$2" ]; then
        echo -e -n "${col}^${COL_DEF}"
    elif [ "$val" == "$3" ]; then
        echo -e -n "${col}v${COL_DEF}"
    else
        echo -e -n "${COL_YEL}?${COL_DEF}"
    fi
}

acdc_run () {
    local ac=$1
    shift
    local bat=$1
    shift
    val=$($@)
    if [ "$cur_state" == "1" -a "$val" == "$ac" ]; then
        col=$COL_GRN
    elif [ "$cur_state" == "0" -a "$val" == "$bat" ]; then
        col=$COL_GRN
    else
        col=$COL_RED
    fi
    if [ "$val" == "$ac" ]; then
        echo -e -n "${col}^${COL_DEF}"
    elif [ "$val" == "$bat" ]; then
        echo -e -n "${col}v${COL_DEF}"
    else
        echo -e -n "${COL_YEL}?${COL_DEF}"
    fi
}

acdc_test () {
    if [ "$cur_state" == "1" -a "$1" == "$2" ]; then
        col=$COL_GRN
    elif [ "$cur_state" == "0" -a "$1" == "$3" ]; then
        col=$COL_GRN
    else
        col=$COL_RED
    fi
    if [ "$1" == "$2" ]; then
        echo -e -n "${col}^${COL_DEF}"
    elif [ "$1" == "$3" ]; then
        echo -e -n "${col}v${COL_DEF}"
    else
        echo -e -n "${COL_YEL}?${COL_DEF}"
    fi
}

display_module() {
    has_mod "$1" || return
    echo -n " -> $1 "
    mod_loaded "$1" && echo "loaded" || echo "not loaded"
}

display_wireless() {
    echo " -> $1 $(iw dev "$1" get power_save)"
}

hibernate_offset() {
    filefrag -v /hibernate | awk 'NR==4 {print $3}'
}

root_part() {
    df / | awk 'NR==2 {print $1}'
}

has_swap_part () {
    grep -qs swap /etc/fstab
}

can_suspend_to_disk () {
    [[ -f /hibernate ]] || has_swap_part
}

swap_part() {
    awk '/swap/ {print $1; exit}' /etc/fstab
}

resume_boot_option() {
    if [[ -f /hibernate ]]; then
        echo "resume=$(root_part) resume_offset=$(hibernate_offset)"
    elif has_swap_part; then
        echo "resume=$(swap_part)"
    fi
}

# lock the file until the script finishes
lock() {
    local LOCK=/tmp/fd-pm.lock
    if [[ -f $LOCK ]]; then
        echo "Working... $LOCK"
        exit
    fi
    : > $LOCK
    trap "rm -f $LOCK" EXIT
}

# $1 = device path
is_usb_hid() {
    local subdev
    if [ "${1/\/sys\/bus\/usb\/*/}" != "" ]; then
        return 1
    fi

    for subdev in $1/*:*; do
        # USB_DEVICE_CLASS 3 = HID
        [[ "$(< "$subdev/bInterfaceClass")" == 03 ]] && return 0
    done

    return 1
}

usb_powersave() {
    local usbdev
    for usbdev in /sys/bus/usb/devices/+([^:]); do
        is_usb_hid "$usbdev" && opt $usbdev/power/control on || opt $usbdev/power/control auto
    done
}
